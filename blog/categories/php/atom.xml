<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: PHP | Gustavo Rodrigues]]></title>
  <link href="http://gustavobeavis.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://gustavobeavis.github.io/"/>
  <updated>2014-12-10T22:50:19-02:00</updated>
  <id>http://gustavobeavis.github.io/</id>
  <author>
    <name><![CDATA[Gustavo da Silva Rodrigues]]></name>
    <email><![CDATA[gustavo.beavis@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Web-socket-php]]></title>
    <link href="http://gustavobeavis.github.io/blog/2014/09/11/web-socket-php/"/>
    <updated>2014-09-11T21:14:11-03:00</updated>
    <id>http://gustavobeavis.github.io/blog/2014/09/11/web-socket-php</id>
    <content type="html"><![CDATA[<p><img src="/../images/title_post_socket.png" alt="imagem" /></p>

<p>A web como conhecemos é baseada em solicitação/resposta de HTTP, ou seja, em cada site que você acessa, em cada solicitação AJAX que é feita ao servidor, temos uma alocação de um novo processo HTTP que entrará em uma fila pra ser respondido e o tempo de retorno pode variar de acordo com a capacidade do servidor em lidar com esses processos, sejam eles paralelos ou concorrentes, requisições simples ou requisições que dependam de uma grande capacidade computacional.</p>

<p>Agora quando pensamos em uma aplicação de respostas em tempo real, logo nos deparamos com um problema, chamado alta latência, pois, precisaremos consultar nosso servidor muito mais vezes, isso sem contar no número de clientes ativos fazendo requisições ao mesmo recurso ou áreas diferentes do mesmo sistema, causando lentidão no servidor e em casos mais graves, teremos problemas como timeout de execução ou queda do servidor.</p>

<h2>Event loop</h2>

<p><img src="/../images/event_loop.png" alt="imagem" /></p>

<p>Toda aplicação realtime, necessariamente possui um loop de consulta de estado ou evento, isso pode estar tanto do lado cliente como do lado servidor. Esse loop ficará escutando a aplicação aguardando alguma mudança de estado, e caso haja atualização, o sistema deve enviar esses dados, a diferença entre o loop do cliente e o do servidor é que no caso do servidor temos um único serviço que irá ficar escutando todas as requisições e mandando as mudanças em tempo real para todos ou algum cliente específico via socket, já no caso do cliente, teremos um script long pooling em todos os clientes, que irá consultar periodicamente o servidor e receber as possíveis alterações do servidor.</p>

<h2>Primeiro socket PHP</h2>

<p>Para criar um socket com php, você deve seguir 6 passos, que vão da abertura de um socket até remover a mascara da mensagem resolver seu encode.</p>

<h4>Passos:</h4>

<ol>
<li>Abrir um socket.</li>
<li>Vincular a um endereço.</li>
<li>Escutar conexões de entrada</li>
<li>Aceitar conexões</li>
<li>WebSocket Handshake.</li>
</ol>


<h3>Passo 1 – Abrir um socket:</h3>

<p>Primeiro vamos criar um socket com <a href="http://php.net/manual/pt_BR/function.socket-create.php">socket_create</a>(Domain, Type, Protocol) do PHP:</p>

<p><code>php
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
</code></p>

<h3>Passo 2 – Vincular a um endereço:</h3>

<p><a href="http://php.net/manual/pt_BR/function.socket-bind.php">socket_bind()</a> recebe como parâmetro o resource do socket que já foi criado com o socket_create(), o endereço e  opcionalmente a porta.
Isto tem que ser feito antes que uma conexão seja estabelecida, usando socket_connect() ou socket_listen().</p>

<p><code>php
socket_bind($socket, 'localhost');
</code></p>

<h3>Passo 3 – Escutar conexões de entrada</h3>

<p>Após o socket ter sido criado usando socket_create e associado para um nome com socket_bind() , ele deve dizer para aguardar por escuta em conexões que irão entrar socket com o <a href="http://php.net/manual/pt_BR/function.socket-listen.php">socket_listen()</a>.</p>

<p><code>php
socket_listen($socket);
</code></p>

<h3>Passo 4 – Aceitar conexões</h3>

<p>Após o socket ter sido criado usando socket_create(), passar um nome com socket_bind(), e dizer para listar conexões com socket_listen(), a função <a href="http://php.net/manual/pt_BR/function.socket-accept.php">socket_accept()</a> irá aceitar conexões vindas neste socket. Uma vez que uma conexão é feita com sucesso , um novo “resource” do socket é retornado, que deve ser usado para comunicação. Se há múltiplas conexões na fila do socket, a primeira irá ser usada. Se não há conexões pendentes, socket_accept() irá bloquear até que uma conexão esteja presente.</p>

<p><code>php
socket_accept($socket);
</code></p>

<h3>Passo 5 – WebSocket Handshake</h3>

<p>O cliente tem de apresentar-se, enviando uma solicitação WebSocket handshake para estabelecer uma conexão bem sucedida com o servidor, o pedido contém um Sec-WebSocket-Key que é uma chave em base64 de 16 bytes</p>

<p><code>php
$secKey = $headers['Sec-WebSocket-Key'];
$secAccept = base64_encode(pack('H*', sha1($secKey . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11')));
$upgrade  = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n" .
"Upgrade: websocket\r\n" .
"Connection: Upgrade\r\n" .
"WebSocket-Origin: $host\r\n" .
"WebSocket-Location: ws://$host:$port/deamon.php\r\n".
"Sec-WebSocket-Accept:$secAccept\r\n\r\n";
socket_write($client_conn,$upgrade,strlen($upgrade));
</code></p>

<h3>Passo 5 – WebSocket Handshake</h3>

<p>Depois de fazer handshaking, o cliente pode enviar e receber mensagens, mas as mensagens enviadas são todas criptografadas, por isso, se queremos exibi-las, precisamos remover a mascara de cada frame de dado, conforme o <a href="http://tools.ietf.org/html/rfc6455#section-5.2">rfc6455</a>.</p>

<p>```php
//Unmask incoming framed message</p>

<p>function unmask($text) {</p>

<pre><code>$length = ord($text[1]) &amp; 127;
if($length == 126) {
    $masks = substr($text, 4, 4);
    $data = substr($text, 8);
}
elseif($length == 127) {
    $masks = substr($text, 10, 4);
    $data = substr($text, 14);
}
else {
    $masks = substr($text, 2, 4);
    $data = substr($text, 6);
}
$text = "";
for ($i = 0; $i &lt; strlen($data); ++$i) {
    $text .= $data[$i] ^ $masks[$i%4];
}
return $text;
</code></pre>

<p>}</p>

<p>//Encode message for transfer to client.
function mask($text)
{</p>

<pre><code>$b1 = 0x80 | (0x1 &amp; 0x0f);
$length = strlen($text);

if($length &lt;= 125)
    $header = pack('CC', $b1, $length);
elseif($length &gt; 125 &amp;&amp; $length &lt; 65536)
    $header = pack('CCn', $b1, 126, $length);
elseif($length &gt;= 65536)
    $header = pack('CCNN', $b1, 127, $length);
return $header.$text;
</code></pre>

<p>}
```</p>

<h3>Executar</h3>

<p>Para executar o Socket basta você acessar o seu terminal e executar o script que serve como servidor, pois se inicia-lo via browser, o seu socket não funcionará.</p>

<p><code>
php -q path-to-server/server.php
</code></p>

<p>Veja o Exemplo completo no <a href="https://github.com/gustavobeavis/ws_pure_php">github</a>.</p>

<h2>O React PHP</h2>

<p>O React PHP é uma biblioteca que foi criada para suprir uma necessidade crescente de computação reativa, ela fornece entre outras coisas a possibilidade de criar aplicações com IO não blocante, como o NodeJS.</p>

<h3>Um chat com React e Ratchet</h3>

<p>O Rachet possui um conjunto de soluções que abstraem e facilitam a criação, manutenção, envios e recebimentos de mensagens de um socket. Você terá que gerenciar os eventos do seu socket, com as funções.</p>

<h4>Funções</h4>

<ol>
<li>onOpen</li>
<li>onMessage</li>
<li>onClose</li>
<li>onError</li>
</ol>


<h3>onOpen</h3>

<p>Essa função é chamada assim que ocorre uma nova conexão, nela você usa um método para guardar a nova conexão para enviar mensagens.</p>

<p>```php
public function onOpen(ConnectionInterface $conn) {
  // Store the new connection to send messages to later
  $this->clients->attach($conn);</p>

<p>  echo &ldquo;New connection! ({$conn->resourceId})\n&rdquo;;
}
```</p>

<h3>onMessage</h3>

<p>Essa função é chamada quando o evento de existe uma nova mensagem, e com ela, você pode encaminhar essas mensagens para todos ou para alguns clientes conectados ao socket</p>

<p>```php
public function onMessage(ConnectionInterface $from, $msg) {</p>

<pre><code>$numRecv = count($this-&gt;clients) - 1;
echo sprintf('Connection %d sending message "%s" to %d other connection%s' . "\n"
    , $from-&gt;resourceId, $msg, $numRecv, $numRecv == 1 ? '' : 's');
$dados = json_decode($msg, true);
$dados['id'] = $from-&gt;resourceId;

foreach ($this-&gt;clients as $client) {

        // The sender is not the receiver, send to each client connected
        $client-&gt;send(json_encode($dados));

}
</code></pre>

<p>}
```</p>

<h3>onClose</h3>

<p>Essa função é chamada assim que um um cliente se desconecta do websocket, e a partir dele, você pode atribuir callbacks para esse evento.</p>

<p>```php
public function onClose(ConnectionInterface $conn) {</p>

<pre><code>// The connection is closed, remove it, as we can no longer send it messages
$this-&gt;clients-&gt;detach($conn);

echo "Connection {$conn-&gt;resourceId} has disconnected\n";
</code></pre>

<p>}
```</p>

<h3>onError</h3>

<p>Esse evento é disparado quando ocorre um erro interno no servidor.</p>

<p>```php
public function onError(ConnectionInterface $conn, \Exception $e) {</p>

<pre><code>echo "An error has occurred: {$e-&gt;getMessage()}\n";

$conn-&gt;close();
</code></pre>

<p>}
```</p>

<h3>Executar</h3>

<p>Para executar o Socket basta você acessar o seu terminal e executar o script que serve como servidor, pois se inicia-lo via browser, o seu socket não funcionará.</p>

<p><code>
php -q path-to-server/server.php
</code></p>

<p>Veja o Exemplo completo no <a href="https://github.com/gustavobeavis/ws_react_basic">github</a>.</p>

<h2>Javascript</h2>

<p>Uma vez criado o socket, você pode acessa-lo do seu browser, lembrando que para acessa-lo de forma nativa, só browsers modernos suportem a API websocket, do contrário, existem diversas saídas, como flashsocket e javasocket, no qual você pode acessa-lo do seu script.</p>

<p>Assim como no caso do servidor, teremos funções com callbacks para todos os eventos de um socket, que são:</p>

<p>```javascript
var wsUri = &ldquo;ws://localhost:1234&rdquo;;
var connection = new WebSocket(wsUri);
// When the connection is open, send some data to the server
connection.onopen = function () {
  connection.send(&lsquo;Ping&rsquo;); // Send the message &lsquo;Ping&rsquo; to the server
};</p>

<p>// Log errors
connection.onerror = function (error) {
  console.log(&lsquo;WebSocket Error &rsquo; + error);
};</p>

<p>// Log messages from the server
connection.onmessage = function (e) {
  console.log(&lsquo;Server: &rsquo; + e.data);
};
```</p>

<p>Eu fiz um exemplo completo usando Angular js, que encontra-se no <a href="https://github.com/gustavobeavis/ws_angular">github</a>.</p>

<h2>Vantagens e desvantagens</h2>

<p>A vantagem de usar um websoket é que ao invés de termos muitos clientes fazendo requisições periódicas http ao mesmo endpoint para verificar possíveis mudanças de estado da aplicação, o socket que irá gerenciar as alterações e mandar para o(os) clientes essas atualizações logo que elas ocorrerem, evitando um tráfego desnecessário de requisições http, como consultas de estado sem mudança ou ainda muitos clientes consultando a mesma coisa. Em contra partida, teremos um script executando um loop infinito no servidor, aguardando algum evento para transmitir para os usuários, ou seja, embora você resolva a latência, você terá um processo que irá consumir recursos do servidor durante todo tempo de que você mante-lo rodando, independente se houver ou não novos eventos, solicitações ou usuários ativos.</p>

<p>Além disso, podemos ter situações onde o navegador do cliente não tenha suporte websoket, flash ou java. Nesses casos, não teremos como evitar o uso de long pooling.</p>

<p>O Websoket é o futuro, porém, o PHP não é a melhor saída para esse tipo de recurso, embora funcione bem na maioria dos casos. Eu aconselho o uso de Erlang ou Node JS, por serem linguagens de natureza não blocante e por lidarem melhor com concorrência.</p>

<h2>Aplicações</h2>

<p>Os websockets podem ter muitas aplicações, sobre tudo, em:</p>

<ul>
<li>Chats</li>
<li>Games multi-player online</li>
<li>Sistemas de sincronização mobile/Web</li>
</ul>


<h2>Referências</h2>

<p><a href="http://www.html5rocks.com/pt/tutorials/websockets/basics/">HTML5 Rocks – Apresentando WebSockets – PT</a></p>

<p><a href="Sergio%20Lopes%20%E2%80%93%20SPYD%20e%20HTTP%202.0%20%E2%80%93%20PT">Sergio Lopes – SPYD e HTTP 2.0 – PT</a></p>

<p><a href="http://blog.glaucocustodio.com/2012/09/22/otimizando-performance-com-compactacao-gzip-deflate/">JustCode – Otimizando Performance com Compactação Gzip/Deflate</a></p>

<p><a href="http://www.sanwebe.com/2013/05/chat-using-websocket-php-socket">Sanwebe – mple Chat Using WebSocket and PHP Socket – EN</a></p>

<p><a href="http://socketo.me/">Ratchet – Lib</a></p>

<p><a href="http://socket.io/">socket.io</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Processando Uma Pilha De Imagens Sem Traumas]]></title>
    <link href="http://gustavobeavis.github.io/blog/2014/04/03/processando-uma-pilha-de-imagens-sem-traumas/"/>
    <updated>2014-04-03T23:09:59-03:00</updated>
    <id>http://gustavobeavis.github.io/blog/2014/04/03/processando-uma-pilha-de-imagens-sem-traumas</id>
    <content type="html"><![CDATA[<p><img src="/../images/destaque_reduz_image.png" alt="imagem" /></p>

<p>Quem nunca precisou processar um número consideravel de imagens para um relatório, não tem idéia da dor de cabeça que isso pode dar. Em um mundo ideal, todo thumb ou imagem tratada, é gerada no momento do upload, porém por diversos fatores, podemos nos deparar com a necessidade de fazer isso sob demanda, e como todos sabemos, isso pode implicar em uma série de problemas, como demora ao gerar essas imagens, e em situações mais graves, podemos ter um estouro de memória, lentidão no servidor, timeout na execução, em fim, tudo que você não quer fazer.</p>

<p>Pensando nisso, vamos desenvolver uma solução que ataca os principais gargalos desse tipo de tarefa, que são a ausência de <strong>threds</strong> em <strong>PHP</strong> e o processo de <strong>IO</strong>.</p>

<h2>Solução</h2>

<p>Iremos desenvolver um serviço capaz de de criar as imagens que ainda não foram criadas, e melhor, paralelamente, e usando um recurso que não usa diretamente a thread do <strong>php</strong></p>

<h3>Checando os arquivos a serem gerados</h3>

<p>Vamos criar um processo capaz de criar thumbs de imagens que ainda não foram criadas, de modo que, antes de começarmos a processar nossa pilha de imagens saberemos o que devemos ou não criar, além disso, ao invés de checar a existência dessas imagens em um loop de file_exists, vamos primeiro listar todos os arquivos da pasta destino e guardar em um array (uma única requisição ao invés de varias requisições em um loop de file_exists), depois disso vamos fazer um diff_contains dos dos arrays de images a serem processadas com as imagens do servidor, ai o array resultante, é o array de imagens que precisamos criar (que não estão no servidor).</p>

<p>```php
// Origem
$origin = scandir(&lsquo;image/origin&rsquo;);
$origin = array_slice($origin,2,count($origin));</p>

<p>//destino
$destination = scandir(&lsquo;image/destination&rsquo;);
$destination = array_slice($destination,2,count($destination));</p>

<p>//Imagens a serem geradas
$terms_list = array_diff($origin, $destination);
```</p>

<h3>Criando os Thumbs</h3>

<p>Já resolvemos o primeiro problema, que é checar quais imagens devemos criar os thumbs, agora temos dois problemas, na verdade um, só que dividido em duas partes, que é o processo de gerar e salvar as imagens. E como todos nós sabemos, todo processo de IO é custoso, isso sem contar com o custo de processamento que o PHP tem ao tratar essas imagens antes de salva-la. Como não temos threds no PHP, temos que gerar uma fila de execução, o que gera um grande buzy-waiting, de modo que pode até causar um timeout do servidor. Para resolver esse problema, precisamos dividir esse processo em duas partes, a primeira é processar as imagens em paralelo (usando o cURL mult_exec), depois usar a solução mais eficaz para processar as imagens que é usar o <strong>Imagemagick</strong> ao invés do GD.</p>

<blockquote><p><strong>Por que Imagemagick?</strong></p>

<p>O Imagemagick ao contrario do GD executa seus processos fora do PHP, ou seja, ele não vai consumir o processo do PHP para fazer sua mágica, além disso, se compararmos a qualidade da imagem gerada entre um e outro, o Imagemagick consegue ter um nível bem superior ao GD.</p></blockquote>

<p>Vamos criar uma classe capaz de usar ambas as bibliotecas, pois, desse modo, independente de haver ou não o Imagemagick no servidor, essas imagens serão geradas.</p>

<h5>Interface Image</h5>

<p>Vamos primeiramente criar um contrato, para que todas as classes de imagens apliquem os métodos usando o mesmo critério, embora de modo diferente.</p>

<p><strong><em>Image.php</em></strong>:
```php
/<em>*
 * Interface Image
 </em>/
interface Image{</p>

<pre><code>/**
 * @param $file
 * @param $anchor
 */
function open($file, $anchor);

/**
 * @param $width
 * @param $height
 */
function resize($width, $height);

/**
 * @param $file
 * @param $quality
 */
function save($file, $quality);
</code></pre>

<p>```</p>

<h5>Classe imageGenerateGD</h5>

<p>Feito Isso, vamos criar nossa Classe que usa o GD para criar nossos thumbs.</p>

<p><strong><em>imageGenerateGD.php</em></strong>:
```php
include_once &ldquo;Image.php&rdquo;;</p>

<p>/<em>*
 * Class imageGenerateGD
 </em>/
class imageGenerateGD implements  Image{</p>

<pre><code>private $image;

public function __construct(){
    $options = func_get_args();
    if(count($options)){
        $this-&gt;open($options[0]);
    }

}

/**
 * @param $file
 * @param string $anchor
 * @return $this
 */
function open($file, $anchor = ''){
    $imagePath = $anchor.$file;
    switch (pathinfo($imagePath)) {
        case 'gif':
            $this-&gt;image = imagecreatefromgif($imagePath);
            break;
        case 'png':
            $this-&gt;image = imagecreatefrompng($imagePath);
            break;
        case 'jpg':
        case 'jpeg':
        case 'pjpeg':
        default:
            $this-&gt;image = imagecreatefromjpeg($imagePath);
            break;
    }
    imagealphablending($this-&gt;image, true);
    imagesavealpha($this-&gt;image, true);
    imagecolorallocate($this-&gt;image, 0, 0, 0);

    return $this;
}

/**
 * @param $width
 * @param $height
 * @return $this
 */
function resize($width = 160, $height = 160){

    // get the current image dimensions
    $geo = array(
        'width'     =&gt;  imagesx($this-&gt;image),
        'height'    =&gt;  imagesy($this-&gt;image)
    );

    $original_aspect = $geo['width'] / $geo['height'];
    $thumb_aspect = $width / $height;

    if ( $original_aspect &gt;= $thumb_aspect )
    {
        // If image is wider than thumbnail (in aspect ratio sense)
        $new_height = $height;
        $new_width = $geo['width'] / ($geo['height'] / $height);
    }
    else
    {
        // If the thumbnail is wider than the image
        $new_width = $width;
        $new_height = $geo['height'] / ($geo['width'] / $width);
    }

    $thumb = imagecreatetruecolor( $width, $height );

    // Resize and crop
    imagecopyresampled($thumb,
        $this-&gt;image,
        0 - ($new_width - $width) / 2, // Center the image horizontally
        0 - ($new_height - $height) / 2, // Center the image vertically
        0, 0,
        $new_width, $new_height,
        $geo['width'], $geo['height']);
    $this-&gt;image = $thumb;
    return $this;
}

/**
 * @param $file
 * @param int $quality
 * @return $this
 */
function save($file, $quality = 90){
    imagejpeg($this-&gt;image,$file, intval($quality));
    imagedestroy($this-&gt;image);
    return $this;
}
</code></pre>

<p>}
```</p>

<h5>Classe imageGenerateImagick</h5>

<p>Agora vamos criar nossa classe que usa o Imagemagick para criar os thumbs.</p>

<p><strong><em>imageGenerateImagick.php</em></strong>:
```php
include_once &ldquo;Image.php&rdquo;;</p>

<p>/<em>*
 * Class imageGenerateImagick
 </em>/
class imageGenerateImagick implements Image{</p>

<pre><code>private $image;

public function __construct(){
    $options = func_get_args();
    if(count($options)){
        $this-&gt;image = new Imagick($options[0]);
    } else {
        $this-&gt;image = new Imagick();
    }

}

/**
 * @param $file
 * @param $anchor
 * @return imageGenerateImagick
 */
function open($file, $anchor = ''){
    $this-&gt;image-&gt;readImage($file);
    return $this;
}

/**
 * @param int $width
 * @param int $height
 * @return imageGenerateImagick
 */
function resize($width = 160, $height = 90){

    $geo = $this-&gt;image-&gt;getImageGeometry();

    // crop the image
    if(($geo['width']/$width) &lt; ($geo['height']/$height)){
        $this-&gt;image-&gt;cropImage($geo['width'], floor($height*$geo['width']/$width), 0, (($geo['height']-($height*$geo['width']/$width))/2));
    } else {
        $this-&gt;image-&gt;cropImage(ceil($width*$geo['height']/$height), $geo['height'], (($geo['width']-($width*$geo['height']/$height))/2), 0);
    }
    // thumbnail the image
    $this-&gt;image-&gt;ThumbnailImage($width,$height,true);
    return $this;

}

/**
 * @param $file
 * @param int $quality
 * @return imageGenerateImagick
 */
function save($file, $quality = 80){
    $this-&gt;image-&gt;setImageCompression(Imagick::COMPRESSION_JPEG);
    $this-&gt;image-&gt;setImageCompressionQuality(intval($quality));
    $this-&gt;image-&gt;writeImage( $file );
    $this-&gt;image-&gt;clear();
    $this-&gt;image-&gt;destroy();
    return $this;
}
</code></pre>

<p>}
```</p>

<h5>Classe ImageGenerate</h5>

<p>Vamos criar nossa classe que implementa ambas as classes, de GD e imagick, no caso, você irá definir qual recurso ele vai usar, e além disso, ele vai checar se tem e extensão do imagick, de modo que se não houver, o sistema irá utilizar o GD.</p>

<p><strong><em>ImageGenerate.php</em></strong>:
```php
include_once &ldquo;Image.php&rdquo;;
include_once &ldquo;ImageGenerateImagick.php&rdquo;;
include_once &ldquo;imageGenerateGD.php&rdquo;;
class ImageGenerate implements Image {</p>

<pre><code>private $image;
private $mode;
const MODE_IMAGICK = 1;
const MODE_GD = 2;
public function __construct(){
    $options = func_get_args();

    if(!isset($options[1])){
        $options[1] = self::MODE_IMAGICK;
    }

    if($options[1] == self::MODE_IMAGICK &amp;&amp; extension_loaded('imagick')){
        if(count($options)){
            $this-&gt;image = new imageGenerateImagick($options[0]);
        } else {
            $this-&gt;image = new imageGenerateImagick();
        }
    } else {
        if(count($options)){
            $this-&gt;image = new imageGenerateGD($options[0]);
        } else {
            $this-&gt;image = new imageGenerateGD();
        }
    }

}

/**
 * @param mixed $mode
 */
public function setMode($mode)
{
    $this-&gt;mode = $mode;
}

/**
 * @return mixed
 */
public function getMode()
{
    return $this-&gt;mode;
}

/**
 * @param $file
 * @param string $anchor
 * @return imageGenerateGD/imageGenerateImagick
 */
function open($file, $anchor = ''){
    $this-&gt;image-&gt;open($file, $anchor);
    return $this-&gt;image;
}

/**
 * @param int $width
 * @param int $height
 * @return imageGenerateGD/imageGenerateImagick
 */
function resize($width = 160, $height = 160){
    $this-&gt;image-&gt;resize(160,160);
    return $this-&gt;image;

}

/**
 * @param $file
 * @param int $quality
 * @return imageGenerateGD/imageGenerateImagick
 */
function save($file, $quality = 80){
    $this-&gt;image-&gt;save($file,$quality);
    return $this-&gt;image;
}
</code></pre>

<p>}
```</p>

<h3>Criando o serviço de crop</h3>

<p>Agora que já temos nossas classes de imagem, vamos criar um serviço ou melhor, uma API, que ao receber como parâmetro o nome e caminho da imagem de origem, ela se encarrega de gerar o thumb usando nossa classe.</p>

<p><strong><em>resize.php</em></strong>:
```php
header(&lsquo;Content-Type: application/json&rsquo;);
if($_REQUEST[&lsquo;file&rsquo;]){</p>

<pre><code>include_once "../class/ImageGenerate.php";
if(file_exists($_REQUEST['file'])){
    $teste = new imageGenerate($_REQUEST['file']);
    $width = (isset($_REQUEST['width']))? $_REQUEST['width'] : 160;
    $height = (isset($_REQUEST['height']))? $_REQUEST['height'] : 160;
    $teste-&gt;resize($width,$height)
          -&gt;save('../image/destination/'.end(explode("/", $_REQUEST['file'])));
    echo json_encode(array(
        'status'    =&gt;  'OK',
        'msg'       =&gt;   utf8_encode('Image save on '.'image/destination/'.end(explode("/", $_REQUEST['file'])))
    ), true);

} else {
    echo json_encode(array(
        'status'    =&gt;  'ERROR',
        'msg'       =&gt;  utf8_encode('picture does not exist')
    ), true);
}
</code></pre>

<p>} else {</p>

<pre><code>echo json_encode(array(
    'status'    =&gt;  'ERROR',
    'msg'       =&gt;  utf8_encode('not sent parameter')
), true);
</code></pre>

<p>}
```</p>

<h3>Processando nossas imagens em paralelo</h3>

<p>Agora que criamos nossas classes de imagens, e a API que gera as imagens, vamos criar uma página que utiliza um recurso do <strong>cURL</strong>, que é o <strong>curl_multi_exec</strong>, ele permite múltiplas requisições simultâneas a nossa API. No nosso caso, utilizamos uma Classe chamada <strong><a href="https://github.com/takinbo/rolling-curl">RollingCurl</a></strong>, ela permite fazer essas chamadas paralelas, permitindo fazer os processos em lotes definidos, por exemplo, executar lotes de 5 em 5 imagens, após completar um lote, ele chama outro, até o fim do processamento. Fizemos apenas uma alteração, que foi criar um método que armazena todas as respostas em um array.</p>

<blockquote><p><strong>Cuidado</strong>
Requisições paralelas são recursos que devem ser usados com consciência, pois você irá forçar o seu servidor a processar <strong>N</strong> vezes em paralelo um determinado recurso, e se considerarmos que podemos ter <strong>X</strong> pessoas usando esse serviço ao mesmo tempo, podemos até derrubar nosso servidor (Não queremos fazer um auto ataque <strong>DDos</strong>).</p></blockquote>

<p><strong><em>RollingCurl.php</em></strong>:
```php
/*
Authored by Josh Fraser (www.joshfraser.com)
Released under Apache License 2.0</p>

<p>Maintained by Alexander Makarov, <a href="http://rmcreative.ru/">http://rmcreative.ru/</a></p>

<p>$Id$
*/</p>

<p>/<em>*
 * Class that represent a single curl request
 </em>/
class RollingCurlRequest {
  public $url = false;
  public $method = &lsquo;GET&rsquo;;
  public $post_data = null;
  public $headers = null;
  public $options = null;</p>

<pre><code>/**
 * @param string $url
 * @param string $method
 * @param  $post_data
 * @param  $headers
 * @param  $options
 * @return void
 */
function __construct($url, $method = "GET", $post_data = null, $headers = null, $options = null) {
    $this-&gt;url = $url;
    $this-&gt;method = $method;
    $this-&gt;post_data = $post_data;
    $this-&gt;headers = $headers;
    $this-&gt;options = $options;
}

/**
 * @return void
 */
public function __destruct() {
    unset($this-&gt;url, $this-&gt;method, $this-&gt;post_data, $this-&gt;headers, $this-&gt;options);
}
</code></pre>

<p>}</p>

<p>/<em>*
 * RollingCurl custom exception
 </em>/
class RollingCurlException extends Exception {}</p>

<p>/<em>*
 * Class that holds a rolling queue of curl requests.
 *
 * @throws RollingCurlException
 </em>/
class RollingCurl {</p>

<pre><code>/**
 * @var int
 *
 * Window size is the max number of simultaneous connections allowed.
</code></pre>

<ul>
<li><ul>
<li>REMEMBER TO RESPECT THE SERVERS:</li>
<li>Sending too many requests at one time can easily be perceived</li>
<li>as a DOS attack. Increase this window_size if you are making requests</li>
<li>to multiple servers or have permission from the receving server admins.
*/
private $window_size = 5;</li>
</ul>


<p>/**</p>

<ul>
<li>@var float
*</li>
<li>Timeout is the timeout used for curl_multi_select.
*/
private $timeout = 10;</li>
</ul>


<p>/**</p>

<ul>
<li>@var string|array
*</li>
<li>Callback function to be applied to each result.
*/
private $callback;</li>
</ul>


<p>/**</p>

<ul>
<li>@var array
*</li>
<li>Set your base options that you want to be used with EVERY request.
*/
protected $options = array(
CURLOPT_SSL_VERIFYPEER => 0,
 CURLOPT_RETURNTRANSFER => 1,
 CURLOPT_CONNECTTIMEOUT => 30,
 CURLOPT_TIMEOUT => 30
);</li>
</ul>


<p>  /**</p>

<ul>
<li> @var array
*/
private $headers = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @var Request[]
*</li>
<li> The request queue
*/
private $requests = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @var RequestMap[]
*</li>
<li> Maps handles to request indexes
*/
private $requestMap = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @var returns[]
*</li>
<li> All returns of requests
*/
private $returns = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @param  $callback</li>
<li> Callback function to be applied to each result.
*</li>
<li> Can be specified as &lsquo;my_callback_function&rsquo;</li>
<li> or array($object, &lsquo;my_callback_method&rsquo;).
*</li>
<li> Function should take three parameters: $response, $info, $request.</li>
<li> $response is response body, $info is additional curl info.</li>
<li> $request is the original request
*</li>
<li> @return void
*/
function __construct($callback = null) {
  $this->callback = $callback;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @param string $name</li>
<li> @return mixed
*/
public function __get($name) {
  return (isset($this->{$name})) ? $this->{$name} : null;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @param string $name</li>
<li> @param mixed $value</li>
<li> @return bool
*/
public function __set($name, $value){
  // append the base options &amp; headers
  if ($name == &ldquo;options&rdquo; || $name == &ldquo;headers&rdquo;) {
      $this->{$name} = $value + $this->{$name};
  } else {
      $this->{$name} = $value;
  }
  return true;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Add a request to the request queue
*</li>
<li> @param Request $request</li>
<li> @return bool
*/
public function add($request) {
   $this->requests[] = $request;
   return true;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @param \returns[] $returns
*/
public function setReturns($returns)
{
  $this->returns = $returns;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @return \returns[]
*/
public function getReturns()
{
  return $this->returns;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Create new Request and add it to the request queue
*</li>
<li> @param string $url</li>
<li> @param string $method</li>
<li> @param  $post_data</li>
<li> @param  $headers</li>
<li> @param  $options</li>
<li> @return bool
*/
public function request($url, $method = &ldquo;GET&rdquo;, $post_data = null, $headers = null, $options = null) {
   $this->requests[] = new RollingCurlRequest($url, $method, $post_data, $headers, $options);
   return true;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Perform GET request
*</li>
<li> @param string $url</li>
<li> @param  $headers</li>
<li> @param  $options</li>
<li> @return bool
*/
public function get($url, $headers = null, $options = null) {
  return $this->request($url, &ldquo;GET&rdquo;, null, $headers, $options);
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Perform POST request
*</li>
<li> @param string $url</li>
<li> @param  $post_data</li>
<li> @param  $headers</li>
<li> @param  $options</li>
<li> @return bool
*/
public function post($url, $post_data = null, $headers = null, $options = null) {
  return $this->request($url, &ldquo;POST&rdquo;, $post_data, $headers, $options);
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Execute the curl
*</li>
<li> @param int $window_size Max number of simultaneous connections</li>
<li> @return string|bool
*/
public function execute($window_size = null) {
  // rolling curl window must always be greater than 1
  if (sizeof($this->requests) == 1) {
      return $this->single_curl();
  } else {
      // start the rolling curl. window_size is the max number of simultaneous connections
      return $this->rolling_curl($window_size);
  }
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Performs a single curl request
*</li>
<li> @access private</li>
<li><p> @return string
*/
private function single_curl() {
  $ch = curl_init();    <br/>
  $request = array_shift($this->requests);
  $options = $this->get_options($request);
  curl_setopt_array($ch,$options);
  $output = curl_exec($ch);
  $info = curl_getinfo($ch);</p>

<p>  // it&rsquo;s not neccesary to set a callback for one-off requests
  if ($this->callback) {
      $callback = $this->callback;
      if (is_callable($this->callback)){
          call_user_func($callback, $output, $info, $request);
      }
  }
else
      return $output;
return true;
}</p></li>
</ul>


<p>  /**</p>

<ul>
<li> Performs multiple curl requests
*</li>
<li> @access private</li>
<li> @throws RollingCurlException</li>
<li> @param int $window_size Max number of simultaneous connections</li>
<li><p> @return bool
*/
private function rolling_curl($window_size = null) {
  if ($window_size)
      $this->window_size = $window_size;</p>

<p>  // make sure the rolling window isn&rsquo;t greater than the # of urls
  if (sizeof($this->requests) &lt; $this->window_size)
      $this->window_size = sizeof($this->requests);</p>

<p>  if ($this->window_size &lt; 2) {
      throw new RollingCurlException(&ldquo;Window size must be greater than 1&rdquo;);
  }</p>

<p>  $master = curl_multi_init();</p>

<p>  // start the first batch of requests
  for ($i = 0; $i &lt; $this->window_size; $i++) {
      $ch = curl_init();</p>

<pre><code>  $options = $this-&gt;get_options($this-&gt;requests[$i]);

  curl_setopt_array($ch,$options);
  curl_multi_add_handle($master, $ch);

  // Add to our request Maps
  $key = (string) $ch;
  $this-&gt;requestMap[$key] = $i;
</code></pre>

<p>  }</p>

<p>  do {
      while(($execrun = curl_multi_exec($master, $running)) == CURLM_CALL_MULTI_PERFORM);
      if($execrun != CURLM_OK) {
          break;
      }
      // a request was just completed &mdash; find out which one
      while($done = curl_multi_info_read($master)) {</p>

<pre><code>      // get the info and content returned on the request
      $info = curl_getinfo($done['handle']);
      $output = curl_multi_getcontent($done['handle']);

      array_push($this-&gt;returns, array(
          'return'    =&gt;  $output,
          'info'      =&gt;  $info,
      ));

      // send the return values to the callback function.
      $callback = $this-&gt;callback;
      if (is_callable($callback)){
    $key = (string)$done['handle'];
          $request = $this-&gt;requests[$this-&gt;requestMap[$key]];
          unset($this-&gt;requestMap[$key]);
          call_user_func($callback, $output, $info, $request);
      }

      // start a new request (it's important to do this before removing the old one)
      if ($i &lt; sizeof($this-&gt;requests) &amp;&amp; isset($this-&gt;requests[$i]) &amp;&amp; $i &lt; count($this-&gt;requests)) {
          $ch = curl_init();
          $options = $this-&gt;get_options($this-&gt;requests[$i]);
          curl_setopt_array($ch,$options);
          curl_multi_add_handle($master, $ch);

          // Add to our request Maps
          $key = (string) $ch;
          $this-&gt;requestMap[$key] = $i;
          $i++;
      }

      // remove the curl handle that just completed
      curl_multi_remove_handle($master, $done['handle']);

  }

  // Block for data in / output; error handling is done by curl_multi_exec
  if ($running) {
      curl_multi_select($master, $this-&gt;timeout);
  }
</code></pre>

<p>  } while ($running);
  curl_multi_close($master);
  return true;
}</p></li>
</ul>


<p>  /**</p>

<ul>
<li> Helper function to set up a new request by setting the appropriate options
*</li>
<li> @access private</li>
<li> @param Request $request</li>
<li><p> @return array
*/
private function get_options($request) {
  // options for this entire curl object
  $options = $this-><strong>get(&lsquo;options&rsquo;);
  // NOTE: The PHP cURL library won&rsquo;t follow redirects if either safe_mode is on
  // or open_basedir is defined.
  // See: <a href="https://bugs.php.net/bug.php?id=30609">https://bugs.php.net/bug.php?id=30609</a>
if (( ini_get(&lsquo;safe_mode&rsquo;) == &lsquo;Off&rsquo; || !ini_get(&lsquo;safe_mode&rsquo;) )
      &amp;&amp; ini_get(&lsquo;open_basedir&rsquo;) == &lsquo;&rsquo;) {
      $options[CURLOPT_FOLLOWLOCATION] = 1;
    $options[CURLOPT_MAXREDIRS] = 5;
  }
  $headers = $this-></strong>get(&lsquo;headers&rsquo;);</p>

<p>// append custom options for this specific request
if ($request->options) {
      $options = $request->options + $options;
  }</p>

<p>// set the request URL
  $options[CURLOPT_URL] = $request->url;</p>

<p>  // posting data w/ this request?
  if ($request->post_data) {
      $options[CURLOPT_POST] = 1;
      $options[CURLOPT_POSTFIELDS] = $request->post_data;
  }
  if ($headers) {
      $options[CURLOPT_HEADER] = 0;
      $options[CURLOPT_HTTPHEADER] = $headers;
  }</p>

<p>  // Due to a bug in cURL CURLOPT_WRITEFUNCTION must be defined as the last option
  // Otherwise it doesn&rsquo;t register. So let&rsquo;s unset and set it again
  // See <a href="http://stackoverflow.com/questions/15937055/curl-writefunction-not-being-called">http://stackoverflow.com/questions/15937055/curl-writefunction-not-being-called</a>
  if( ! empty( $options[CURLOPT_WRITEFUNCTION]) ) {
      $writeCallback = $options[CURLOPT_WRITEFUNCTION];
      unset( $options[CURLOPT_WRITEFUNCTION] );
      $options[CURLOPT_WRITEFUNCTION] = $writeCallback;
  }</p>

<p>  return $options;
}</p></li>
</ul>


<p>  /**</p>

<ul>
<li> @return void
*/
public function __destruct() {
  unset($this->window_size, $this->callback, $this->options, $this->headers, $this->requests);
}
}
```</li>
</ul>
</li>
</ul>


<p><strong><em>RollingCurl.php</em></strong>:
```php
/*
Authored by Josh Fraser (www.joshfraser.com)
Released under Apache License 2.0</p>

<p>Maintained by Alexander Makarov, <a href="http://rmcreative.ru/">http://rmcreative.ru/</a></p>

<p>$Id$
*/</p>

<p>/<em>*
 * Class that represent a single curl request
 </em>/
class RollingCurlRequest {
  public $url = false;
  public $method = &lsquo;GET&rsquo;;
  public $post_data = null;
  public $headers = null;
  public $options = null;</p>

<pre><code>/**
 * @param string $url
 * @param string $method
 * @param  $post_data
 * @param  $headers
 * @param  $options
 * @return void
 */
function __construct($url, $method = "GET", $post_data = null, $headers = null, $options = null) {
    $this-&gt;url = $url;
    $this-&gt;method = $method;
    $this-&gt;post_data = $post_data;
    $this-&gt;headers = $headers;
    $this-&gt;options = $options;
}

/**
 * @return void
 */
public function __destruct() {
    unset($this-&gt;url, $this-&gt;method, $this-&gt;post_data, $this-&gt;headers, $this-&gt;options);
}
</code></pre>

<p>}</p>

<p>/<em>*
 * RollingCurl custom exception
 </em>/
class RollingCurlException extends Exception {}</p>

<p>/<em>*
 * Class that holds a rolling queue of curl requests.
 *
 * @throws RollingCurlException
 </em>/
class RollingCurl {</p>

<pre><code>/**
 * @var int
 *
 * Window size is the max number of simultaneous connections allowed.
</code></pre>

<ul>
<li><ul>
<li>REMEMBER TO RESPECT THE SERVERS:</li>
<li>Sending too many requests at one time can easily be perceived</li>
<li>as a DOS attack. Increase this window_size if you are making requests</li>
<li>to multiple servers or have permission from the receving server admins.
*/
private $window_size = 5;</li>
</ul>


<p>/**</p>

<ul>
<li>@var float
*</li>
<li>Timeout is the timeout used for curl_multi_select.
*/
private $timeout = 10;</li>
</ul>


<p>/**</p>

<ul>
<li>@var string|array
*</li>
<li>Callback function to be applied to each result.
*/
private $callback;</li>
</ul>


<p>/**</p>

<ul>
<li>@var array
*</li>
<li>Set your base options that you want to be used with EVERY request.
*/
protected $options = array(
CURLOPT_SSL_VERIFYPEER => 0,
 CURLOPT_RETURNTRANSFER => 1,
 CURLOPT_CONNECTTIMEOUT => 30,
 CURLOPT_TIMEOUT => 30
);</li>
</ul>


<p>  /**</p>

<ul>
<li> @var array
*/
private $headers = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @var Request[]
*</li>
<li> The request queue
*/
private $requests = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @var RequestMap[]
*</li>
<li> Maps handles to request indexes
*/
private $requestMap = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @var returns[]
*</li>
<li> All returns of requests
*/
private $returns = array();</li>
</ul>


<p>  /**</p>

<ul>
<li> @param  $callback</li>
<li> Callback function to be applied to each result.
*</li>
<li> Can be specified as &lsquo;my_callback_function&rsquo;</li>
<li> or array($object, &lsquo;my_callback_method&rsquo;).
*</li>
<li> Function should take three parameters: $response, $info, $request.</li>
<li> $response is response body, $info is additional curl info.</li>
<li> $request is the original request
*</li>
<li> @return void
*/
function __construct($callback = null) {
  $this->callback = $callback;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @param string $name</li>
<li> @return mixed
*/
public function __get($name) {
  return (isset($this->{$name})) ? $this->{$name} : null;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @param string $name</li>
<li> @param mixed $value</li>
<li> @return bool
*/
public function __set($name, $value){
  // append the base options &amp; headers
  if ($name == &ldquo;options&rdquo; || $name == &ldquo;headers&rdquo;) {
      $this->{$name} = $value + $this->{$name};
  } else {
      $this->{$name} = $value;
  }
  return true;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Add a request to the request queue
*</li>
<li> @param Request $request</li>
<li> @return bool
*/
public function add($request) {
   $this->requests[] = $request;
   return true;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @param \returns[] $returns
*/
public function setReturns($returns)
{
  $this->returns = $returns;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> @return \returns[]
*/
public function getReturns()
{
  return $this->returns;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Create new Request and add it to the request queue
*</li>
<li> @param string $url</li>
<li> @param string $method</li>
<li> @param  $post_data</li>
<li> @param  $headers</li>
<li> @param  $options</li>
<li> @return bool
*/
public function request($url, $method = &ldquo;GET&rdquo;, $post_data = null, $headers = null, $options = null) {
   $this->requests[] = new RollingCurlRequest($url, $method, $post_data, $headers, $options);
   return true;
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Perform GET request
*</li>
<li> @param string $url</li>
<li> @param  $headers</li>
<li> @param  $options</li>
<li> @return bool
*/
public function get($url, $headers = null, $options = null) {
  return $this->request($url, &ldquo;GET&rdquo;, null, $headers, $options);
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Perform POST request
*</li>
<li> @param string $url</li>
<li> @param  $post_data</li>
<li> @param  $headers</li>
<li> @param  $options</li>
<li> @return bool
*/
public function post($url, $post_data = null, $headers = null, $options = null) {
  return $this->request($url, &ldquo;POST&rdquo;, $post_data, $headers, $options);
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Execute the curl
*</li>
<li> @param int $window_size Max number of simultaneous connections</li>
<li> @return string|bool
*/
public function execute($window_size = null) {
  // rolling curl window must always be greater than 1
  if (sizeof($this->requests) == 1) {
      return $this->single_curl();
  } else {
      // start the rolling curl. window_size is the max number of simultaneous connections
      return $this->rolling_curl($window_size);
  }
}</li>
</ul>


<p>  /**</p>

<ul>
<li> Performs a single curl request
*</li>
<li> @access private</li>
<li><p> @return string
*/
private function single_curl() {
  $ch = curl_init();    <br/>
  $request = array_shift($this->requests);
  $options = $this->get_options($request);
  curl_setopt_array($ch,$options);
  $output = curl_exec($ch);
  $info = curl_getinfo($ch);</p>

<p>  // it&rsquo;s not neccesary to set a callback for one-off requests
  if ($this->callback) {
      $callback = $this->callback;
      if (is_callable($this->callback)){
          call_user_func($callback, $output, $info, $request);
      }
  }
else
      return $output;
return true;
}</p></li>
</ul>


<p>  /**</p>

<ul>
<li> Performs multiple curl requests
*</li>
<li> @access private</li>
<li> @throws RollingCurlException</li>
<li> @param int $window_size Max number of simultaneous connections</li>
<li><p> @return bool
*/
private function rolling_curl($window_size = null) {
  if ($window_size)
      $this->window_size = $window_size;</p>

<p>  // make sure the rolling window isn&rsquo;t greater than the # of urls
  if (sizeof($this->requests) &lt; $this->window_size)
      $this->window_size = sizeof($this->requests);</p>

<p>  if ($this->window_size &lt; 2) {
      throw new RollingCurlException(&ldquo;Window size must be greater than 1&rdquo;);
  }</p>

<p>  $master = curl_multi_init();</p>

<p>  // start the first batch of requests
  for ($i = 0; $i &lt; $this->window_size; $i++) {
      $ch = curl_init();</p>

<pre><code>  $options = $this-&gt;get_options($this-&gt;requests[$i]);

  curl_setopt_array($ch,$options);
  curl_multi_add_handle($master, $ch);

  // Add to our request Maps
  $key = (string) $ch;
  $this-&gt;requestMap[$key] = $i;
</code></pre>

<p>  }</p>

<p>  do {
      while(($execrun = curl_multi_exec($master, $running)) == CURLM_CALL_MULTI_PERFORM);
      if($execrun != CURLM_OK) {
          break;
      }
      // a request was just completed &mdash; find out which one
      while($done = curl_multi_info_read($master)) {</p>

<pre><code>      // get the info and content returned on the request
      $info = curl_getinfo($done['handle']);
      $output = curl_multi_getcontent($done['handle']);

      array_push($this-&gt;returns, array(
          'return'    =&gt;  $output,
          'info'      =&gt;  $info,
      ));

      // send the return values to the callback function.
      $callback = $this-&gt;callback;
      if (is_callable($callback)){
    $key = (string)$done['handle'];
          $request = $this-&gt;requests[$this-&gt;requestMap[$key]];
          unset($this-&gt;requestMap[$key]);
          call_user_func($callback, $output, $info, $request);
      }

      // start a new request (it's important to do this before removing the old one)
      if ($i &lt; sizeof($this-&gt;requests) &amp;&amp; isset($this-&gt;requests[$i]) &amp;&amp; $i &lt; count($this-&gt;requests)) {
          $ch = curl_init();
          $options = $this-&gt;get_options($this-&gt;requests[$i]);
          curl_setopt_array($ch,$options);
          curl_multi_add_handle($master, $ch);

          // Add to our request Maps
          $key = (string) $ch;
          $this-&gt;requestMap[$key] = $i;
          $i++;
      }

      // remove the curl handle that just completed
      curl_multi_remove_handle($master, $done['handle']);

  }

  // Block for data in / output; error handling is done by curl_multi_exec
  if ($running) {
      curl_multi_select($master, $this-&gt;timeout);
  }
</code></pre>

<p>  } while ($running);
  curl_multi_close($master);
  return true;
}</p></li>
</ul>


<p>  /**</p>

<ul>
<li> Helper function to set up a new request by setting the appropriate options
*</li>
<li> @access private</li>
<li> @param Request $request</li>
<li><p> @return array
*/
private function get_options($request) {
  // options for this entire curl object
  $options = $this-><strong>get(&lsquo;options&rsquo;);
  // NOTE: The PHP cURL library won&rsquo;t follow redirects if either safe_mode is on
  // or open_basedir is defined.
  // See: <a href="https://bugs.php.net/bug.php?id=30609">https://bugs.php.net/bug.php?id=30609</a>
if (( ini_get(&lsquo;safe_mode&rsquo;) == &lsquo;Off&rsquo; || !ini_get(&lsquo;safe_mode&rsquo;) )
      &amp;&amp; ini_get(&lsquo;open_basedir&rsquo;) == &lsquo;&rsquo;) {
      $options[CURLOPT_FOLLOWLOCATION] = 1;
    $options[CURLOPT_MAXREDIRS] = 5;
  }
  $headers = $this-></strong>get(&lsquo;headers&rsquo;);</p>

<p>// append custom options for this specific request
if ($request->options) {
      $options = $request->options + $options;
  }</p>

<p>// set the request URL
  $options[CURLOPT_URL] = $request->url;</p>

<p>  // posting data w/ this request?
  if ($request->post_data) {
      $options[CURLOPT_POST] = 1;
      $options[CURLOPT_POSTFIELDS] = $request->post_data;
  }
  if ($headers) {
      $options[CURLOPT_HEADER] = 0;
      $options[CURLOPT_HTTPHEADER] = $headers;
  }</p>

<p>  // Due to a bug in cURL CURLOPT_WRITEFUNCTION must be defined as the last option
  // Otherwise it doesn&rsquo;t register. So let&rsquo;s unset and set it again
  // See <a href="http://stackoverflow.com/questions/15937055/curl-writefunction-not-being-called">http://stackoverflow.com/questions/15937055/curl-writefunction-not-being-called</a>
  if( ! empty( $options[CURLOPT_WRITEFUNCTION]) ) {
      $writeCallback = $options[CURLOPT_WRITEFUNCTION];
      unset( $options[CURLOPT_WRITEFUNCTION] );
      $options[CURLOPT_WRITEFUNCTION] = $writeCallback;
  }</p>

<p>  return $options;
}</p></li>
</ul>


<p>  /**</p>

<ul>
<li> @return void
*/
public function __destruct() {
  unset($this->window_size, $this->callback, $this->options, $this->headers, $this->requests);
}
}
```</li>
</ul>
</li>
</ul>


<p><strong><em>RollingCurlGroup.php</em></strong>:
```php
/*</p>

<p>  Authored by Fabian Franz (www.lionsad.de)
  Released under Apache License 2.0</p>

<p>$Id$
*/</p>

<p>class RollingCurlGroupException extends Exception {}</p>

<p>abstract class RollingCurlGroupRequest extends RollingCurlRequest
{</p>

<pre><code>    private $group = null;
</code></pre>

<p>  /<em>*
  * Set group for this request
  *
  * @param group The group to be set
  </em>/</p>

<pre><code>    function setGroup($group)
    {
            if (!($group instanceof RollingCurlGroup))
                    throw new RollingCurlGroupException("setGroup: group needs to be of instance RollingCurlGroup");

            $this-&gt;group = $group;
    }
</code></pre>

<p>  /<em>*
  * Process the request
  *
  *
  </em>/</p>

<pre><code>    function process($output, $info)
    {
            if ($this-&gt;group)
                    $this-&gt;group-&gt;process($output, $info, $this);
    }
</code></pre>

<p>  /<em>*
  * @return void
  </em>/
  public function __destruct() {</p>

<pre><code>  unset($this-&gt;group);
  parent::__destruct();
</code></pre>

<p>  }</p>

<p>}</p>

<p>class RollingCurlGroup
{</p>

<pre><code>    protected $name;
    protected $num_requests = 0;
    protected $finished_requests = 0;
    private $requests = array();

    function __construct($name)
    {
            $this-&gt;name = $name;
    }
</code></pre>

<p>  /<em>*
  * @return void
  </em>/
  public function __destruct() {</p>

<pre><code>  unset($this-&gt;name, $this-&gt;num_requests, $this-&gt;finished_requests, $this-&gt;requests);
</code></pre>

<p>  }</p>

<pre><code>    function add($request)
    {
            if ($request instanceof RollingCurlGroupRequest)
            {
                    $request-&gt;setGroup($this);
                    $this-&gt;num_requests++;
                    $this-&gt;requests[] = $request;
            }
  else if (is_array($request))
            {
      foreach ($request as $req)
          $this-&gt;add($req);
  }
            else
                    throw new RollingCurlGroupException("add: Request needs to be of instance RollingCurlGroupRequest");

  return true;
    }

    function addToRC($rc)
    {
  $ret = true;

            if (!($rc instanceof RollingCurl))
                    throw new RollingCurlGroupException("addToRC: RC needs to be of instance RollingCurl");

            while (count($this-&gt;requests) &gt; 0)
  {
      $ret1 = $rc-&gt;add(array_shift($this-&gt;requests));
      if (!$ret1)
          $ret = false;
  }

  return $ret;
    }

    function process($output, $info, $request)
    {
            $this-&gt;finished_requests++;

            if ($this-&gt;finished_requests &gt;= $this-&gt;num_requests)
                    $this-&gt;finished();
    }

    function finished()
    {
    }
</code></pre>

<p>}</p>

<p>class GroupRollingCurl extends RollingCurl {</p>

<p>  private $group_callback = null;</p>

<p>  protected function process($output, $info, $request)
  {</p>

<pre><code>  if( $request instanceof RollingCurlGroupRequest)
      $request-&gt;process($output, $info);

  if (is_callable($this-&gt;group_callback))
      call_user_func($this-&gt;group_callback, $output, $info, $request);
</code></pre>

<p>  }</p>

<p>  function __construct($callback = null)
  {</p>

<pre><code>  $this-&gt;group_callback = $callback;

  parent::__construct(array(&amp;$this, "process"));
</code></pre>

<p>  }</p>

<p>  public function add($request)
  {</p>

<pre><code>  if ($request instanceof RollingCurlGroup)
      return $request-&gt;addToRC($this);
  else
      return parent::add($request);
</code></pre>

<p>  }</p>

<p>  public function execute($window_size = null) {</p>

<pre><code>  if (count($this-&gt;requests) == 0)
      return false;

  return parent::execute($window_size);
</code></pre>

<p>  }</p>

<p>}
```</p>

<h3>Fazendo a Mágica</h3>

<p>Agora que temos tudo, vamos criar uma página que faz esse processo para nós, no nosso caso, vamos transferir imagens de uma pasta para outra, mas poderíamos simplesmente chamar isso de um banco de dados, ou outro lugar.</p>

<p><strong><em>index.php</em></strong>:
```php
require_once &ldquo;class/RollingCurl.php&rdquo;;
define (&lsquo;URLPREFIX&rsquo;, &lsquo;<a href="http://127.0.0.1/processaImagem/services/resize.php">http://127.0.0.1/processaImagem/services/resize.php</a>&rsquo;);</p>

<p>$origin = scandir(&lsquo;image/origin&rsquo;);
$origin = array_slice($origin,2,count($origin));</p>

<p>$destination = scandir(&lsquo;image/destination&rsquo;);
$destination = array_slice($destination,2,count($destination));
$terms_list = array_diff($origin, $destination);</p>

<p>$rc = new RollingCurl();
$rc->window_size = 5; // limit requests per batch
foreach ($terms_list as $terms) {</p>

<pre><code>$search_url = URLPREFIX.'?file='.urlencode("../image/origin/".$terms);
$request = new RollingCurlRequest($search_url);
$rc-&gt;add($request);
</code></pre>

<p>}
if($rc->execute()){</p>

<pre><code>foreach($rc-&gt;getReturns() as $key =&gt; $value){
    echo $value['return']. '&lt;br&gt;';
}
</code></pre>

<p>}
```</p>

<h2>Notas finais</h2>

<p>As vezes nos deparamos com algumas limitações técnicas ou da propria linguagem, e pra resolvermos esses problemas, precisamos pensar fora da caxa. Existem diversas formas para realizarmos esse tipo de tarefa, mas dentro de uma limitação que tive, essa foi sem dúvida a melhor solução.
Solução no github <strong><a href="https://github.com/gustavobeavis/serviceResize">serviceResize</a></strong></p>
]]></content>
  </entry>
  
</feed>
